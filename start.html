<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Get Started with ServiceX</title>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB"
      crossorigin="anonymous"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI"
      crossorigin="anonymous"
    ></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css"
    />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github-dark.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/python.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>

    <link
      href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap"
      rel="stylesheet"
    />

    <style>
      body {
        margin: 0;
        font-family: "Open Sans", sans-serif;
        scroll-behavior: smooth;
        color: #fff;
      }

      h1 {
        font-weight: 700;
        margin-bottom: 1rem;
      }

      p {
        font-size: 1.1rem;
        max-width: 800px;
        text-align: center;
      }

      section {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 3rem;
        transition: background 0.5s;
        text-align: center;
      }

      section:nth-child(odd) {
        background: #212529;
      }
      section:nth-child(even) {
        background: #2d3238;
      }

      .buttons {
        margin-top: 2rem;
      }

      button {
        margin: 0 0.5rem;
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        background: #0d6efd;
        color: white;
        font-size: 1rem;
        transition: background 0.3s ease;
      }

      button:hover {
        background: #0a58ca;
      }

      table {
        width: 80%;
        margin-top: 2rem;
        border-collapse: collapse;
        font-size: 1rem;
      }

      th,
      td {
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 1rem;
        text-align: left;
        vertical-align: top;
      }

      th {
        background-color: rgba(255, 255, 255, 0.1);
        font-weight: 700;
        text-align: center;
      }

      .code-block {
        text-align: left;
        margin-top: 1rem;
      }

      pre code {
        padding-left: 50px !important;
        padding-right: 50px !important;
        border-radius: 8px;
      }
    </style>
  </head>

  <body>

    <section id="beta-title">
      <h1>Welcome to the 15 Minute Histogram Challenge Beta 1</h1>
      <p>
        If you were sent this tutorial it is likley because you already have a working knowledge of ServiceX and how to use it. The tutorial was sent to you
        because you can help get the early tweaks made before we send it to users who know nothing about ServiceX!
      </p>
      <div class="buttons">
        <button onclick="nextStep('beta-be-mean')">Next -></button>
      </div>
    </section>

    <section id="beta-be-mean">
      <h1>Beta 1: Nit Pick Every Detail</h1>
      <p>
        Be like the dad in this video and treat every detail important and nit pick the heck out of this tutorial!
      </p>
      <video
        id="instructionVideo"
        width="auto"
        height="500"
        src="intructions.mp4"
        preload="none"
        controls
        playsinline
      >
        Your browser does not support HTML5 video.
      </video>
      <div class="buttons">
        <button onclick="prevStep('beta-title')">← Back</button>
        <button onclick="nextStep('title')">Start the Challenge! -></button>
      </div>
    </section>

    <section id="title">
      <h1>The ServiceX 15 Minute Histogram Challenge</h1>
      <p>
        This quick-start challenge will guide you through creating your first
        histogram with <strong>ServiceX</strong> and do it in under 15 minutes! In just a few steps, you'll be
        ready to fetch and analyze data seamlessly.
      </p>
      <div class="buttons">
        <button onclick="prevStep('beta-be-mean')">← Back</button>
        <button onclick="nextStep('step1')">Lets Go! →</button>
      </div>
    </section>

    <section id="step1">
      <h1>Step 1: Install ServiceX</h1>
      <p>
        To begin, install the <strong>ServiceX client</strong> using
        <code>pip</code>. Open your terminal and run:
      </p>
      <div class="code-block">
        <pre><code class="language-bash">pip install servicex</code></pre>
      </div>
      <p>
        We will also be using some utility functions that are in a separate package:
      </p>
      <div class="code-block">
        <pre><code class="language-bash">pip install servicex-analysis-utils</code></pre>
      </div>
      <div class="buttons">
        <button onclick="prevStep('title')">← Back</button>
        <button onclick="nextStep('step2')">Next →</button>
      </div>
    </section>

    <section id="step2">
      <h1>Step 2: Initialize ServiceX</h1>
      <p>
        After installation, connect your client to the Analysis Facility. This
        step authenticates your environment and sets up access.
      </p>
      <div class="code-block">
        <pre><code class="language-bash">servicex init atlas</code></pre>
      </div>
      <p>
        You’ll be prompted to log in via a provided link. Once authenticated, you
        should see a success message. You can confirm the setup by running:
      </p>
      <div class="code-block">
        <pre><code class="language-bash">servicex init test</code></pre>
      </div>
      <div class="buttons">
        <button onclick="prevStep('step1')">← Back</button>
        <button onclick="nextStep('step3')">Next →</button>
      </div>
    </section>

    <section id="step3">
      <h1>Step 3: Prepare Python File</h1>
      <p>
        It is recommended for this tutorial that you use a Juypter Notebook, but if you prefere a normal python script will work just fine.
      </p>
      <div class="buttons">
        <button onclick="prevStep('step2')">← Back</button>
        <button onclick="nextStep('step4')">Next →</button>
      </div>
    </section>

    <section id="step4">
      <h1>Step 4: Choose Your Query Type</h1>
      <p>
        ServiceX supports multiple query backends to suit different workflows.
        Your choice depends on the data type and the complexity of your analysis.
      </p>

      <table>
        <thead>
          <tr>
            <th>Uproot</th>
            <th>FuncADL</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              ✅ Ideal for working with <strong>ROOT ntuples</strong> or flat
              data structures.<br />
              ✅ Use prexisting knowledge of Uproot to build queries<br />
              ✅ Queries run quickly and are easy to setup.<br />
            </td>
            <td>
              ✅ Designed for getting all possible data from <strong>xAOD datasets</strong> <br />
              ✅ Allows writing queries in <strong>Python syntax</strong> that are
              translated into optimized C++ and run in AnalysisBase.<br />
              ✅ Anything that can be done in AnalysisBase can be done with FuncADL.<br />
              ✅ Removes need for cloning, chaning, and building AnalysisBase.<br />
            </td>
          </tr>
          <tr>
            <td>
              ⚠️ Limited to simpler transformations and filtering.<br />
              ⚠️ Does not natively handle complex object hierarchies.<br />
            </td>
            <td>
              ⚠️ Steeper learning curve; use only when necessary.<br />
              ⚠️ Runs slower than Uproot ServiceX.<br />
            </td>
          </tr>
        </tbody>
      </table>

      <div class="buttons">
        <button onclick="prevStep('step3')">← Back</button>
        <button onclick="nextStep('step5u')">Uproot →</button>
        <button onclick="nextStep('step5f')">FuncADL →</button>
      </div>
    </section>

    <section id="step5u">
        <h1>Step 5: Import Needed Functions</h1>
        <p>To create our query and send it to the backend, we need a few functions and classes. Let's import them.</p>
        <div class="code-block">
            <pre><code class="language-python">
from servicex import deliver, query, dataset
            </code></pre>
        </div>
        <p>The dataset and query objects are used to define our request and are then packaged into a spec. The deliver function sends the 
            spec to the backend. We also import one of our analysis utilities, <code>to_awk</code>, which processes the data returned 
            from ServiceX.
        </p>
        <div class="code-block">
            <pre><code class="language-python">
from servicex_analysis_utils import to_awk
            </code></pre>
        </div>
        <div class="buttons">
            <button onclick="prevStep('step4')">← Back</button>
            <button onclick="nextStep('step6u')">Next →</button>
        </div>
    </section>

    <section id="step6u">
        <h1>Step 6: Setting Up Our Dataset</h1>
        <p>Before we build our query and spec, we need to specify our dataset. ServiceX supports multiple types of datasets, but all types must be
            publicly accessible or available to all ATLAS users. More information about supported dataset locations can be found in our full documentation.
            <br/><br/>For this tutorial, we’ll use an NTuple stored in Rucio. If you already have an NTuple available in Rucio, you can use it for this
            tutorial, though the tree and branch names may differ.
        </p>
        <div class="code-block">
            <pre><code class="language-python">
ntuple_dataset = dataset.Rucio("user.acordeir:michigan-tutorial.displaced-signal.root")
            </code></pre>
        </div>
        <div class="buttons">
            <button onclick="prevStep('step5u')">← Back</button>
            <button onclick="nextStep('step7u')">Next →</button>
        </div>
    </section>

    <section id="step7u">
        <h1>Step 7: Building Our Query</h1>
        <p> The second thing needed to construct our spec is the query. Here we define the data we would like selected and we can also define cuts.
            For uproot-raw queries the treename needs to be define, then the branches selected, and then finally cuts can be made.
        </p>
        <div class="code-block">
            <pre><code class="language-python">
uproot_raw_query = query.UprootRaw([{
        'treename':'reco',
        'filter_name':
            ["truth_alp_decayVtxX",
                "truth_alp_decayVtxY",
                "truth_alp_pt",
                "truth_alp_eta",
                "jet_EMFrac_NOSYS", 
                "jet_pt_NOSYS"],
        'cut':
            '(num(jet_pt_NOSYS)<2) & any((truth_alp_pt>20) & (abs(truth_alp_eta)<0.8))'
    }]
)
            </code></pre>
        </div>
        <div class="buttons">
            <button onclick="prevStep('step6u')">← Back</button>
            <button onclick="nextStep('step8u')">Next →</button>
        </div>
    </section>

    <section id="step8u">
        <h1>Step 8: Building The Spec</h1>
        <p>The hard work has been done and now we just need to package everything up in a spec object before we pass it to the deliver.
            Here is how that is done for this example:
        </p>
        <div class="code-block">
            <pre><code class="language-python">
spec_uproot_raw = {
    'Sample': [{
        'Name': 'UprootRawExample',
        'Dataset': ntuple_dataset,
        'Query': uproot_raw_query
    }]
}
            </code></pre>
        </div>
        <div class="buttons">
            <button onclick="prevStep('step7u')">← Back</button>
            <button onclick="nextStep('step9u')">Next →</button>
        </div>
    </section>

    <section id="step9u">
        <h1>Step 9: Deliver The Spec</h1>
        <p>Now that we have a spec setup we can deliver it to the backend.</p>
        <div class="code-block">
            <pre><code class="language-python">
results_uproot_raw=deliver(spec_uproot_raw)
            </code></pre>
        </div>
        <p>The deliver function sends the query to the backend where the transform is processed. Then the processed files are downloaded to the client
          (in a configured directory). The variable results_uproot_raw has a list of those files. This list is what can be used to start the 
          analysis of those files.
        </p>
        <div class="buttons">
            <button onclick="prevStep('step8u')">← Back</button>
            <button onclick="nextStep('step10u')">Next →</button>
        </div>
    </section>

    <section id="step10u">
        <h1>Step 10: Analyze The Data</h1>
        <p>We can load that list of files that the deliver function returned into akward using the to_awk function. Then we can do a standard Histogram
          workflow to finally get our histogram!
        </p>
        <div class="code-block">
            <pre><code class="language-python">
arr = to_awk(results_uproot_raw)["UprootRawExample"]

# compute displacement 
displacement = (arr["truth_alp_decayVtxX"]**2 +
                arr["truth_alp_decayVtxY"]**2)**0.5

# flatten the awkward arrays
emfrac = ak.flatten(arr["jet_EMFrac_NOSYS"])
disp   = ak.flatten(displacement)

# set up side-by-side subplots
fig, axes = plt.subplots(1, 2, figsize=(9, 4))

# EM fraction
axes[0].hist(emfrac, bins=50, range=[0,1] )
axes[0].set_title(f"{name}: Jet EM Fraction")
axes[0].set_xlabel("EM Fraction")
axes[0].set_ylabel("Counts")

# displacement
axes[1].hist(disp, bins=50, range=[0,5000], color="g")
axes[1].set_title(f"{name}: Decay Vertex Displacement")
axes[1].set_xlabel("Displacement in x-y (mm)")
axes[1].set_ylabel("Counts")

plt.tight_layout()
plt.show()
            </code></pre>
        </div>
        <div class="buttons">
            <button onclick="prevStep('step9u')">← Back</button>
            <button onclick="nextStep('step11u')">Next →</button>
        </div>
    </section>

    <section id="step5f">
        <h1>Step 5: Import Needed Functions</h1>
        <p>To create our query and send it to the backend, we need some functions and classes. Let's import them.</p>
        <div class="code-block">
            <pre><code class="language-python">
from servicex import deliver, query, dataset
            </code></pre>
        </div>
        <p>The dataset and query objects are imported to build the specification that will be sent to the backend. The deliver function sends the 
            specification to the backend. We can also import one of our analysis utilities, <code>to_awk</code>, which processes the data returned 
            from ServiceX.
        </p>
        <div class="code-block">
            <pre><code class="language-python">
from servicex_analysis_utils import to_awk
            </code></pre>
        </div>
        <div class="buttons">
            <button onclick="prevStep('step4')">← Back</button>
            <button onclick="nextStep('step6f')">Next →</button>
        </div>
    </section>

    <script>
      function nextStep(id) {
        document.getElementById(id).scrollIntoView({ behavior: "smooth" });
      }

      function prevStep(id) {
        document.getElementById(id).scrollIntoView({ behavior: "smooth" });
      }
    </script>
    <script>
  const video = document.getElementById("instructionVideo");

  const observer = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        video.dataset.visible = entry.isIntersecting; // store visibility state
        if (entry.isIntersecting) {
          video.play().catch(() => {});
        } else {
          video.pause();
        }
      });
    },
    { threshold: 0.25 }
  );

  observer.observe(video);

  // Only unmute and play if visible
  document.addEventListener("click", () => {
    if (video.dataset.visible === "true") {
      video.muted = false;
      video.play().catch(() => {});
    }
  });
</script>


  </body>
</html>
